<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1: Understanding PEG Parsers</title>
    <style>
body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow-x: auto; }
code { font-family: monospace; }
h1, h2, h3 { color: #333; }
a { color: #0066cc; }
    </style>
</head>
<body>
<h1>Chapter 1: Understanding PEG Parsers</h1>
<h2>1.1 Introduction to Parsing Expression Grammars</h2>
<p>Parsing Expression Grammars (PEGs) were formally introduced by Bryan Ford in 2004 as an alternative to Context-Free Grammars (CFGs) for describing syntax. PEGs provide a formal foundation for recursive descent parsers with backtracking, which have been used in practice for decades.</p>
<p>The key insight of PEGs is that they view parsing as a recognition process rather than a generative one. Instead of describing all possible strings that could be generated by a grammar (as CFGs do), PEGs describe a procedure for recognizing whether a string belongs to a language.</p>
<h3>Key Characteristics of PEGs:</h3>
<ol>
<li><strong>Unambiguous</strong>: PEGs always yield at most one valid parse tree for any input string</li>
<li><strong>Ordered Choice</strong>: When multiple alternatives could match, the first matching one is chosen</li>
<li><strong>Unlimited Lookahead</strong>: PEGs can use arbitrary lookahead to make parsing decisions</li>
<li><strong>Integrated Lexical and Syntactic Analysis</strong>: No separate lexer/tokenizer is needed</li>
<li><strong>Recognition-Based</strong>: Focused on recognizing valid inputs rather than generating them</li>
</ol>
<h2>1.2 PEG vs. Context-Free Grammars</h2>
<p>While PEGs and CFGs may appear similar in notation, they differ fundamentally in semantics:</p>
<p>| Aspect | Context-Free Grammars | Parsing Expression Grammars |
|--------|------------------------|----------------------------|
| Ambiguity | Can be ambiguous | Always unambiguous |
| Choice Operator | Unordered (any production can be chosen) | Ordered (first matching rule wins) |
| Implementation | Various algorithms (LL, LR, etc.) | Recursive descent with backtracking |
| Expressiveness | Can express some patterns PEGs cannot | Can express some patterns CFGs cannot |
| Parsing Complexity | Varies by algorithm (O(n) to O(n³)) | O(n) with memoization (Packrat parsing) |
| Whitespace Handling | Requires separate lexer | Can be handled directly in grammar |</p>
<p>The ordered choice operator (<code>/</code> in standard PEG notation, often represented as alternatives in implementations) is perhaps the most significant difference. In a CFG, the expression <code>A → B | C</code> means "A can be either B or C," with no preference specified. In a PEG, the equivalent expression <code>A ← B / C</code> means "Try to match A as B; if that fails, try to match it as C."</p>
<h2>1.3 PEG Operators and Notation</h2>
<p>PEGs use a set of operators to define parsing expressions:</p>
<p>| Operator | Name | Description | Example |
|----------|------|-------------|---------|
| <code>e1 e2</code> | Sequence | Match e1 followed by e2 | <code>"if" Condition Block</code> |
| <code>e1 / e2</code> | Ordered Choice | Try e1; if it fails, try e2 | <code>Addition / Multiplication / Primary</code> |
| <code>e*</code> | Zero-or-More | Match e zero or more times | <code>Statement*</code> |
| <code>e+</code> | One-or-More | Match e one or more times | <code>Digit+</code> |
| <code>e?</code> | Optional | Match e or nothing | <code>"else" Block?</code> |
| <code>&amp;e</code> | And-Predicate | Succeed if e matches but don't consume input | <code>&amp;[a-z]</code> |
| <code>!e</code> | Not-Predicate | Succeed if e doesn't match and don't consume input | <code>![0-9]</code> |
| <code>(e)</code> | Grouping | Group expressions | <code>("+" / "-") Term</code> |</p>
<p>In our TinyPEG implementation, these operators are represented through Python classes rather than this specific syntax. For example:</p>
<ul>
<li><strong>Sequence</strong> → <code>Sequence(expr1, expr2)</code></li>
<li><strong>Ordered Choice</strong> → <code>Choice(expr1, expr2)</code></li>
<li><strong>Zero-or-More</strong> → <code>ZeroOrMore(expr)</code></li>
<li><strong>One-or-More</strong> → <code>OneOrMore(expr)</code></li>
<li><strong>Optional</strong> → <code>Optional(expr)</code></li>
<li><strong>And-Predicate</strong> → <code>AndPredicate(expr)</code></li>
<li><strong>Not-Predicate</strong> → <code>NotPredicate(expr)</code></li>
</ul>
<p>This class-based approach provides better integration with Python and enables more sophisticated parsing behaviors.</p>
<h2>1.4 Recursive Descent Parsing</h2>
<p>PEGs are naturally implemented using recursive descent parsing, a top-down parsing technique where each non-terminal in the grammar corresponds to a function in the parser.</p>
<p>The basic algorithm for a recursive descent PEG parser is:</p>
<ol>
<li>For each grammar rule, create a parsing function</li>
<li>The function attempts to match its rule against the current input position</li>
<li>If successful, it returns the matched result and advances the input position</li>
<li>If unsuccessful, it backtracks to the original position and reports failure</li>
<li>For ordered choice, try each alternative in order until one succeeds or all fail</li>
</ol>
<p>Here's a simplified example of how a recursive descent parser might handle a simple arithmetic expression grammar:</p>
<p>```python
def parse_expression(input, pos):
    # Try to parse as a term
    result, new_pos = parse_term(input, pos)
    if result is not None:
        return result, new_pos
    return None, pos  # Backtrack if unsuccessful</p>
<p>def parse_term(input, pos):
    # Try to parse as a factor
    result, new_pos = parse_factor(input, pos)
    if result is not None:
        return result, new_pos
    return None, pos  # Backtrack if unsuccessful</p>
<p>def parse_factor(input, pos):
    # Try to parse as a number
    if pos &lt; len(input) and input[pos].isdigit():
        # Match one or more digits
        start = pos
        while pos &lt; len(input) and input[pos].isdigit():
            pos += 1
        return int(input[start:pos]), pos
    return None, pos  # Backtrack if unsuccessful
```</p>
<h2>1.5 Packrat Parsing and Memoization</h2>
<p>A naive recursive descent implementation of PEG parsing can have exponential time complexity in the worst case due to backtracking. This is where Packrat parsing comes in.</p>
<p>Packrat parsing is a technique that applies memoization to recursive descent parsing. By caching the results of parsing functions at each input position, it ensures that no parsing function is called more than once at any given position, resulting in linear time complexity.</p>
<p>The basic idea is:</p>
<ol>
<li>Before attempting to parse a rule at a position, check if we've already tried this combination</li>
<li>If we have, return the cached result</li>
<li>Otherwise, perform the parsing and cache the result before returning it</li>
</ol>
<p>Here's how our TinyPEG implementation incorporates memoization:</p>
<p>```python
class PEGParser:
    def <strong>init</strong>(self):
        self.grammar = None
        self.rule_cache = {}  # Memoization cache</p>
<pre><code>def _parse_rule(self, rule, ctx):
    """Parse a rule with memoization."""
    # Check if we've already parsed this rule at this position
    cache_key = (rule.name, ctx.pos)
    if cache_key in self.rule_cache:
        result, new_pos = self.rule_cache[cache_key]
        ctx.pos = new_pos
        return result

    # Save position for backtracking
    start_pos = ctx.pos

    try:
        # Parse the rule's expression
        result = self._parse_expression(rule.expr, ctx)

        # Cache the successful result
        self.rule_cache[cache_key] = (result, ctx.pos)
        return result
    except ParseError:
        # Backtrack on failure
        ctx.pos = start_pos
        raise
</code></pre>
<p>```</p>
<p>Our TinyPEG implementation automatically incorporates memoization in the <code>PEGParser</code> class, ensuring efficient parsing without requiring manual cache management.</p>
<h2>1.6 TinyPEG Implementation Preview</h2>
<p>Our TinyPEG library implements these PEG concepts using a clean, object-oriented Python design:</p>
<ul>
<li><strong>Class-based Grammar Definition</strong>: Grammars are defined using Python classes rather than text files</li>
<li><strong>Automatic Memoization</strong>: Built-in packrat parsing for optimal performance</li>
<li><strong>Integrated Whitespace Handling</strong>: Automatic whitespace management between tokens</li>
<li><strong>Comprehensive Error Reporting</strong>: Detailed error messages with position information</li>
<li><strong>Extensible Architecture</strong>: Easy to extend with custom parsing behaviors</li>
</ul>
<p>Here's a preview of how a simple grammar looks in TinyPEG:</p>
<p>```python
from src.peg import PEGParser, Rule, GrammarNode, Literal, Regex</p>
<h1>Define a simple number parser</h1>
<p>grammar = GrammarNode(
    name="Number",
    rules=[
        Rule("Number", Regex("[0-9]+"))
    ]
)</p>
<h1>Create and use the parser</h1>
<p>parser = PEGParser()
parser.grammar = grammar
result = parser.parse("42")  # Returns "42"
```</p>
<p>In the next chapter, we'll explore the complete architecture and components of the TinyPEG library, seeing how these concepts are implemented in detail.</p>
</body>
</html>
